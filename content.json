{"meta":{"title":"小王和你拼啦!","subtitle":"","description":"这是小王的blog","author":"xiao wang","url":"https://lk-yu.github.io","root":"/"},"pages":[{"title":"Authors","date":"2022-01-07T07:42:15.860Z","updated":"2022-01-07T07:42:15.860Z","comments":true,"path":"author/index.html","permalink":"https://lk-yu.github.io/author/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-01-07T06:05:23.000Z","updated":"2022-01-07T07:36:40.467Z","comments":true,"path":"about/index.html","permalink":"https://lk-yu.github.io/about/index.html","excerpt":"","text":"这是小王的博客啦"},{"title":"Categories","date":"2022-01-07T07:43:18.360Z","updated":"2022-01-07T07:43:18.360Z","comments":true,"path":"categories/index.html","permalink":"https://lk-yu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-01-07T07:42:45.444Z","updated":"2022-01-07T07:42:45.444Z","comments":true,"path":"tags/index.html","permalink":"https://lk-yu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"提高摸鱼技巧","slug":"提高摸鱼技巧","date":"2022-01-20T06:50:00.000Z","updated":"2022-01-20T06:50:10.302Z","comments":true,"path":"提高摸鱼技巧/","link":"","permalink":"https://lk-yu.github.io/%E6%8F%90%E9%AB%98%E6%91%B8%E9%B1%BC%E6%8A%80%E5%B7%A7/","excerpt":"","text":"1.声明和初始化数组我们可以使用特定的大小来初始化数组，也可以通过指定值来初始化数组内容，大家可能用的是一维数组，其实二维数组也可以这样做，如下所示： 12345678910111213const array = Array(5).fill(&#x27;&#x27;);// 输出(5) [&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]const matrix = Array(5).fill(0).map(()=&gt;Array(5).fill(0))// 输出(5) [Array(5), Array(5), Array(5), Array(5), Array(5)]0: (5) [0, 0, 0, 0, 0]1: (5) [0, 0, 0, 0, 0]2: (5) [0, 0, 0, 0, 0]3: (5) [0, 0, 0, 0, 0]4: (5) [0, 0, 0, 0, 0]length: 5 2.求和,最小值和最大值我们应该利用reduce方法快速找到基本的数学运算. 1const array = [5, 4, 7, 8, 9, 2] 求和 12array.reduce((a, b) =&gt; a+b);// 输出: 35 最大值 123array.reduce((a, b) =&gt; a&gt;b?a:b);Math.max(...array)// 输出: 9 最小值 123array.reduce((a, b) =&gt; a&lt;b?a:b);Math.min(...array)// 输出: 2 3.排序字符串,数字或对象等数组我们有内置的方法sort()和reverse()来排序字符串,但是如果是数字或对象数组呢 字符串数组排序 1234567const stringArr = [&quot;Joe&quot;, &quot;Kapil&quot;, &quot;Steve&quot;, &quot;Musk&quot;];stringArr.sort();// 输出(4) [&#x27;Joe&#x27;, &#x27;Kapil&#x27;, &#x27;Musk&#x27;, &#x27;Steve&#x27;]stringArr.reverse();// 输出(4) [&#x27;Musk&#x27;, &#x27;Steve&#x27;, &#x27;Kapil&#x27;, &#x27;Joe&#x27;] 数字数组排序 1234567const array = [40, 100, 1, 5, 25, 10];array.sort((a,b) =&gt; a-b);// 输出(6) [1, 5, 10, 25, 40, 100]array.sort((a,b) =&gt; b-a);// 输出(6) [100, 40, 25, 10, 5, 1] 对象数组排序 123456789101112const objectArr = [ &#123; first_name: &#x27;Lazslo&#x27;, last_name: &#x27;Jamf&#x27; &#125;, &#123; first_name: &#x27;Pig&#x27;, last_name: &#x27;Bodine&#x27; &#125;, &#123; first_name: &#x27;Pirate&#x27;, last_name: &#x27;Prentice&#x27; &#125;];objectArr.sort((a, b) =&gt; a.last_name.localeCompare(b.last_name));// 输出 (3) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;]0: &#123;first_name: &quot;Pig&quot;, last_name: &quot;Bodine&quot;&#125;1: &#123;first_name: &quot;Lazslo&quot;, last_name: &quot;Jamf&quot;&#125;2: &#123;first_name: &quot;Pirate&quot;, last_name: &quot;Prentice&quot;&#125;length: 3 4.从数组中过滤到虚值像0,undefined,null,false,””,’’这样的假值可以通过下面的技巧轻易地过滤掉 1234const array = [3, 0, 6, 7, &#x27;&#x27;, false];array.filter(Boolean);// 输出(3) [3, 6, 7] 5.使用逻辑运算符处理需要条件判断的情况12345678910111213141516function doSomething(arg1)&#123; arg1 = arg1 || 10; // 如果arg1没有值，则取默认值 10&#125;// orfunction doSomething(arg1=10)&#123; &#125;let foo = 10;foo === 10 &amp;&amp; doSomething();// 如果 foo 等于 10, 刚执行 doSomething();// 输出: 10foo === 5 || doSomething();// is the same thing as if (foo != 5) then doSomething();// Output: 10 6.去除重复值12345const array = [5, 4, 7, 8, 9, 2, 7, 5];array.filter((item,idx,arr) =&gt; arr.indexOf(item) === idx);// orconst nonUnique = [...new Set(array)];// Output: [5, 4, 7, 8, 9, 2] 7.创建一个计数器对象或Map大多数情况下,可以通过创建一个对象或者Map来计数某些特殊词出现的频率. 1234567let string = &#x27;kapilalipak&#x27;;const table = &#123;&#125;;for(let char of string) &#123; table[char] = table[char]+1 || 1;&#125;// 输出&#123;k: 2, a: 3, p: 2, i: 2, 1: 2&#125; 或者 12345678910const countMap = new Map(); for (let i = 0; i &lt; string.length; i++) &#123; if (countMap.has(string[i])) &#123; countMap.set(string[i], countMap.get(string[i]) + 1); &#125; else &#123; countMap.set(string[i], 1); &#125; &#125;// 输出Map(5) &#123;&quot;k&quot; =&gt; 2, &quot;a&quot; =&gt; 3, &quot;p&quot; =&gt; 2, &quot;i&quot; =&gt; 2, &quot;l&quot; =&gt; 2&#125; 8.三元运算符很酷12345678function Fever(temp) &#123; return temp &gt; 97 ? &#x27;Visit Doctor!&#x27; : temp &lt; 97 ? &#x27;Go Out and Play!!&#x27; : temp === 97 ? &#x27;Take Some Rest!&#x27; : &#x27;Go Out and Play!&#x27;;&#125;// 输出Fever(97): &quot;Take Some Rest!&quot;Fever(100): &quot;Visit Doctor!&quot; 9.循环方法的比较 for 和 for..in 默认获取索引, 但你可以使用 arr[index]. for..in 也接受非数字, 所以要避免使用. forEach,for…of直接得到元素. forEach也可以得到索引,但for…of不行 10.合并两个对象1234567891011121314151617181920212223const user = &#123; name: &#x27;Kapil Raghuwanshi&#x27;, gender: &#x27;Male&#x27;&#125;;const college = &#123; primary: &#x27;Mani Primary School&#x27;, secondary: &#x27;Lass Secondary School&#x27;&#125;;const skills = &#123; programming: &#x27;Extreme&#x27;, swimming: &#x27;Average&#x27;, sleeping: &#x27;Pro&#x27;&#125;;const summary = &#123;...user, ...college, ...skills&#125;;// 合并多个对象gender: &quot;Male&quot;name: &quot;Kapil Raghuwanshi&quot;primary: &quot;Mani Primary School&quot;programming: &quot;Extreme&quot;secondary: &quot;Lass Secondary School&quot;sleeping: &quot;Pro&quot;swimming: &quot;Average&quot; 11.箭头函数箭头函数表达式是传统函数表达式的一种替代方式,但受到限制,不能在所有情况下使用。因为它们有词法作用域(父作用域), 并且没有自己的this和argument,因此它们引用定义它们的环境。 123456789const person = &#123; name: &#x27;Kapil&#x27;, sayName() &#123; return this.name; &#125;&#125;person.sayName();// 输出&quot;kapil&quot; 但是这样: 12345678const person = &#123;name: &#x27;Kapil&#x27;,sayName : () =&gt; &#123; return this.name; &#125;&#125;person.sayName();// Output 12.可选的链1234567891011const user = &#123; employee: &#123; name: &quot;Kapil&quot; &#125;&#125;;user.employee?.name;// Output: &quot;Kapil&quot;user.employ?.name;// Output: undefineduser.employ.name// 输出: VM21616:1 Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined 13.洗牌一个数组利用内置的Math.random()方法. 12345678const list = [1, 2, 3, 4, 5, 6, 7, 8, 9];list.sort(() =&gt; &#123; return Math.random() - 0.5;&#125;);// 输出(9) [2, 5, 1, 6, 9, 8, 4, 3, 7]// 输出(9) [4, 1, 7, 5, 3, 8, 2, 9, 6] 14.双问号语法1234const foo = null ?? &#x27;my school&#x27;;// 输出: &#x27;my school&#x27;const baz = 0 ?? 42;// 输出: 0 剩余和展开语法 123456function myFun(a, b, ...manyMoreArgs) &#123; return arguments.length;&#125;myFun(&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;);// 输出: 6 和 12345const parts = [&#x27;shoulders&#x27;, &#x27;knees&#x27;];const lyrics = [&#x27;head&#x27;, ...parts, &#x27;and&#x27;, &#x27;toes&#x27;];lyrics;// 输出:(5) [&#x27;head&#x27;, &#x27;shoulders&#x27;, &#x27;knees&#x27;, &#x27;and&#x27;, &#x27;toes&#x27;] 16.默认参数12345const search = (arr, low=0, high=arr.length-1) =&gt; &#123; return high;&#125;search([1, 2, 3, 4, 5]);// 输出: 4 17.将十进制转换为二进制或十六进制1234567const num = 10;num.toString(2);// 输出: &quot;1010&quot;num.toString(16);// 输出: &quot;a&quot;num.toString(8);// 输出: &quot;12&quot; 18.使用解构来交换两个数123456let a = 5;let b = 8;[a, b] = [b, a][a, b]// 输出(2) [8, 5] 19.单行的回文数检查12345function checkPalindrome(str) &#123; return str == str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);&#125;checkPalindrome(&#x27;naman&#x27;);// 输出: true 20.将Object属性转换为属性数组123456789101112const obj = &#123;a: 1, b: 2, c: 3&#125;;Object.entries(obj);// Output(3) [Array(2), Array(2), Array(2)]0: (2) [&quot;a&quot;, 1]1: (2) [&quot;b&quot;, 2]2: (2) [&quot;c&quot;, 3]length: 3Object.keys(obj);(3) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]Object.values(obj);(3) [1, 2, 3]","categories":[],"tags":[]},{"title":"JS小知识点(2)","slug":"js知识点(2)","date":"2022-01-11T01:12:00.000Z","updated":"2022-01-11T03:30:23.045Z","comments":true,"path":"js知识点(2)/","link":"","permalink":"https://lk-yu.github.io/js%E7%9F%A5%E8%AF%86%E7%82%B9(2)/","excerpt":"","text":"1.Array.prototype.includes()includes()方法用来判断一个数组中是否包含某个指定的值,包含则返回true,否则返回false 语法 1arr.includes(findVal[,index]) index可选,表示从index索引处开始往后查找.如果为负值,表示从末尾开始往前跳|index|个索引,然后往后查找.默认值为0. 123456let arr = [&#x27;leo&#x27;,&#x27;lion&#x27;,&#x27;ggj&#x27;]console.log(arr.includes(&#x27;leo&#x27;)) // trueconsole.log(arr.includes(&#x27;gao&#x27;)) // falseconsole.log(arr.includes(&#x27;ggj&#x27;,1)) // trueconsole.log(arr.includes(&#x27;Leo&#x27;)) // false// 注意: 使用includes()查找字符串是区分大小写的. 2.幂运算符 **求某个数的幂,之前一般使用Math.pow() 1console.log(Math.pow(2,10)); // 1024 使用幂运算符** 12console.log(2 ** 10); // 1024// 注意: 幂运算符的两个*号之间不能出现空格,否则语法会报错. 3.Object.values()Object.values()返回一个新数组,里面的成员是传入的参数对象自身的(不含继承的)所有可遍历属性对应的值 123456let obj = &#123; name:&#x27;leo&#x27;, age:18, like:&#x27;music&#x27;&#125;;console.log(Object.values(obj)); // [&#x27;leo&#x27;,18,&#x27;music&#x27;] 4.Object.entries()Object.entries()方法返回一个新数组,里面的成员是传入的参数对象本身的(不含继承的)所有可遍历属性的键值对数组 123456let obj = &#123; name:&#x27;leo&#x27;, age:18, like:&#x27;music&#x27;&#125;;console.log(Object.entries(obj)); // [[&#x27;name&#x27;,&#x27;leo&#x27;],[&#x27;age&#x27;,18],[&#x27;like&#x27;,&#x27;music&#x27;]] 扩展:Object.keys()方法返回一个新数组,里面的成员是传入的参数对象本身的(不含继承的)所有可遍历的属性 1234567let obj = &#123; name:&#x27;leo&#x27;, age:18, like:&#x27;music&#x27;&#125;console.log(Object.keys(obj)); // [&#x27;name&#x27;,&#x27;age&#x27;,&#x27;like&#x27;]// 注意: 如果传入的参数是数组,则返回的是所有可遍历的索引. 5.Object.getOwnPropertyDescriptpors()Object.getOwnPropertyDescriptors()方法用来获取传入对象的所有自身属性的描述符 12345678910111213141516171819202122232425262728let obj = &#123; name:&#x27;leo&#x27;, age:18, like:&#x27;music&#x27;&#125;;let desc = Object.getOwnPropertyDescriptors(obj);console.log(desc);// 打印结果&#123; name:&#123; value:&#x27;leo&#x27;, // value表示当前对象的默认值 writable:true, // writable表示对象属性是否可以修改 enumerable:true, // enumerable表示当前这个属性是否可以出现在对象的枚举属性中 configurable:true // 表示当前对象的属性能否用delete删除 &#125;, age:&#123; value:18, writable:true, enumerable:true, configurable:true &#125;, like:&#123; value:&#x27;music&#x27;, writable:true, enumerable:true, configurable:true &#125;,&#125; 我们可以使用Object.defineProperty()修改属性 1234567let obj = &#123;&#125;;Object.defineProperty(obj,&quot;name&quot;,&#123; value:&#x27;leo&#x27;, writable:false, // 设置为false,该属性无法修改 configurable:false, // 设置为false,该属性不支持delete删除 enumerable:false, // 设置为false,该属性不可被枚举&#125;); 验证 1234567891011console.log(obj); // &#123;name:&#x27;leo&#x27;&#125;obj.name = &#x27;lion&#x27;;console.log(obj); // &#123;name:&#x27;leo&#x27;&#125;delete obj.nameconsole.log(obj); // &#123;name:&#x27;leo&#x27;&#125;for (let key in obj) &#123; console.log(key); // &quot;&quot;&#125; 6.String.prototype.padStart把指定字符串填充到字符串头部,返回新字符串. 语法 1str.padStart(targetLength [,padString]) targetLength: 当前字符串需要填充到的目标长度.如果这个数值小于当前字符串的长度,则返回当前字符串本身. padString: 可选,如果字符串太长,使填充后的字符串长度超过了目标长度,则只保留最左侧的部分,其他部分会被截断.默认值为” “. 1234&#x27;abc&#x27;.padStart(10); // &quot; abc&quot;,填充默认值&quot;&quot;&#x27;abc&#x27;.padStart(10, &#x27;*&#x27;); // &quot;*******abc&quot;&#x27;abc&#x27;.padStart(6,&#x27;123465&#x27;); // &quot;123abc&quot;&#x27;abc&#x27;.padStart(1); // &quot;abc&quot; 举例 日期格式化: yyyy-mm-dd的格式 123456let date = new Date();let year = date.getFullYear();// 月日如果是一位前面给它填充一个0let month = (date.getMonth() + 1).toString().padStart(2,&#x27;0&#x27;);let day = (date.getDate()).toString().padStart(2,&#x27;0&#x27;);console.log(`$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`); // 2022-01-09 数字替换(手机号,银行卡号等) 123let tel = &#x27;18937640746&#x27;let newTel = tel.slice(-4).padStart(tel.length,&#x27;*&#x27;)console.log(newTel) // *******0746 7.String.prototype.padEnd把指定字符串填充到字符串尾部,返回新字符串. 语法与padStart相同 1234&#x27;abc&#x27;.padEnd(10); // &quot;abc &quot;,填充默认值&quot;&quot;&#x27;abc&#x27;.padEnd(10,&quot;*&quot;); // &quot;abc*******&quot;&#x27;abc&#x27;.padEnd(6,&quot;123456&quot;); // &quot;abc123&quot;&#x27;abc&#x27;.padEnd(1); // &quot;abc&quot; 8.async/await前面添加了async的函数在执行后都会自动返回一个Promise对象 1234function fn()&#123; return &#x27;leo&#x27;;&#125;console.log(fn()); // &#x27;leo&#x27; 添加async后 1234async function fn()&#123; return &#x27;leo&#x27;; // Promise.resolve(&#x27;leo&#x27;)&#125;console.log(fn()); // Promise对象 async函数中使用await,那么await处的代码就会变成同步的,即只有等await后面的Promise执行完成得到结果才会继续往下执行,await意为等待 1234567891011121314function timeout()&#123; return new Promise(resolve =&gt; &#123; setTimeout(()=&gt; &#123; console.log(1); resolve(); &#125;, 1000); &#125;)&#125;async function fn() &#123; await timeout(); // 执行完成才继续往下执行 console.log(2);&#125;fn(); // 不加async和await是 2,1 加了是 1,2 注意: 1.await只能在 async标记的函数内部使用,单独使用会触发Syntax error; 2.await后面需要跟异步操作,不然就没有意义,而且await后面的Promise对象不必写then,因为await的作用之一就是获取后面Promise对象成功状态传递出来的参数. 9.Rest &amp; Spreadspread例子 12345678910let text = &#123; a:1, b:2, c:3,&#125;let newText = &#123; ...text, c:4&#125;console.log(newText); // &#123;a:1, b:2, c:4&#125; 这块代码展示了spread语法,可以把text对象的数据拓展到newText对象,这个功能很实用.需要注意的是,如果存在相同的属性名,后面的会把前面的覆盖. 如果属性的值是一个对象的话,该对象的引用会被拷贝,而不是生成一个新的对象 123456let obj = &#123;x: &#123;y: 10&#125;&#125;;let copy1 = &#123; ...obj &#125;;let copy2 = &#123; ...obj &#125;;obj.x.y = &#x27;leo&#x27;;console.log(copy1,copy2); // &#123;x: &#123;y: &#x27;leo&#x27;&#125;&#125; &#123;x: &#123;y: &#x27;leo&#x27;&#125;&#125;console.log(copy1.x === copy2.x) // true, x为同一个引用 rest例子 1234567let text = &#123; a:1, b:2, c:3&#125;let &#123;a,...rest&#125; = textconsole.log(a,rest); // 1 &#123;b: 2,c: 3&#125; 当对象key-value不确定的时候,把必选的key赋值给变量,用一个变量接收其他可选的key数据,这在之前是做不到的.注意,rest属性必须始终出现在对象末尾,否则将抛出错误. 10.for await of异步迭代器(for-await-of): 循环等待每个Promise对象变为resolved状态才进入下一步. for…of是同步运行 12345678910function Timeout(time)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(time); &#125;,time); &#125;)&#125;async function test() &#123; let arr = [TimeOut(2000)]&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://lk-yu.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://lk-yu.github.io/tags/JS/"}]},{"title":"xshell常用命令","slug":"xshell常用问题","date":"2022-01-10T02:22:00.000Z","updated":"2022-01-10T03:49:27.279Z","comments":true,"path":"xshell常用问题/","link":"","permalink":"https://lk-yu.github.io/xshell%E5%B8%B8%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"干掉所有文件1rm -rf * 移动当前文件夹下的所有文件到上一级目录1mv * ../","categories":[],"tags":[{"name":"xshell","slug":"xshell","permalink":"https://lk-yu.github.io/tags/xshell/"}]},{"title":"JS小知识点(1)","slug":"js知识点(1)","date":"2022-01-07T09:05:41.000Z","updated":"2022-01-11T01:11:12.945Z","comments":true,"path":"js知识点(1)/","link":"","permalink":"https://lk-yu.github.io/js%E7%9F%A5%E8%AF%86%E7%82%B9(1)/","excerpt":"","text":"1.JavaScript有几种数据类型？ number：数字类型 string：字符串类型 boolean：布尔值类型 undefined：未定义类型 null：空值类型 object：对象类型 symbol：symbol类型 bigint：大数字类型 2.JavaScript最大安全数字与最小安全数字？1234console.log(Number.MAX_SAFE_INTEGER)// 9007199254740991console.log(Number.MIN_SAFE_INTEGER)// -9007199254740991 3.深拷贝与浅拷贝的区别? 深拷贝层层拷贝,浅拷贝只拷贝第一层,深层只是引用 在深拷贝中,新对象中的更改不会影响原始对象,而在浅拷贝中,新对象中的更改,原始对象中也会跟着改 在深拷贝中,原始对象不与新对象共享相同的属性,而在浅拷贝中,它们具有相同的属性 4.闭包是什么? 优点：使外部能访问到局部的东西 缺点：使用不当容易造成内存泄漏的问题 1234567891011// 例子:function a () &#123; let num = 0 // 这是个闭包 return function () &#123; return ++num &#125;&#125;const b = a()console.log(b()) // 1console.log(b()) // 2 5.原型链是什么呀?详细点!6.什么是变量提升?函数提升?123456789101112131415161718192021// 变量提升console.log(name) // undefinedvar name = &#x27;AtDawn&#x27;if(false)&#123; // 有一个预解析过程,在没有执行之前就开始预编译 var age = 23&#125;console.log(age) // undefined 不会报错// 函数提升console.log(fun) // function fun() &#123;&#125;function fun()&#123;&#125;if(false)&#123; function fun2()&#123;&#125;&#125;console.log(fun2) // undefined 不会报错// 函数提升优先级 &gt; 变量提升优先级console.log(fun) // function fun() &#123;&#125;var fun = &#x27;AtDawn&#x27;function fun() &#123;&#125;console.log(fun) // &#x27;AtDawn&#x27; 7.isNaN与Number.isNaN的区别? isNaN：除了判断NaN为true,还会把不能转成数字的判断为true,例如’xxx’ Number.isNaN：只有判断NaN时为true,其余情况都为false 8.解决遍历对象时,把原型上的属性遍历出来了咋办?12345678910function Person(name)&#123; this.name = name&#125;Person.prototype.age = 23const person = new Person(&#x27;AtDawn&#x27;)for(const key in person)&#123;console.log(key)&#125; // name,age// 使用 hasOwnPropertyfor(const key in person)&#123; person.hasOwnProperty(key) &amp;&amp; console.log(key)&#125; // name 9.valueOf与toString valueOf偏向于运算，toString偏向于显示 对象转换时，优先调用toString 强转字符串优先调用toString，强转数字优先调用valueOf 正常情况下，优先调用toString 运算操作符情况下优先调用valueOf 调用valueOf 调用者 返回值 返回值类型 Array 数组本身 Array Boolean 布尔值 Boolean Date 毫秒数 Number Function 函数本身 Function Number 数字值 Number Object 对象本身 Object String 字符串 String 调用toString 调用者 返回值 返回值类型 Array 数组转字符串，相当于Array.join() String Boolean 转字符串’true’，’false’ String Date 字符串日期，如’Fri Dec 23 2016 11:24:47 GMT+0800(中国标准时间)’ String Number 数字字符串 String Object ‘[object Object]’ String String 字符串 String 10.JavaScript变量在内存中具体存储形式? 基本数据类型：存在栈内存里 引用数据类型：指针存栈内存，指向堆内存中一块地址，内容存在堆内存中 也有说法说其实JavaScript所有数据都存堆内存中，我也比较赞同这种说法 11.讲一讲JavaScript的装箱和拆箱?装箱：把基本数据类型转化为对应的引用数据类型的操作 123456789101112// 看以下代码，s1只是一个基本数据类型，他是怎么能调用indexOf的呢？const s1 = &#x27;AtDawn&#x27;const index = s1.indexOf(&#x27;w&#x27;)console.log(index) // 4// 原来是JavaScript内部进行了装箱操作// 1.创建String类型的一个实例// 2.在实例上调用指定的方法// 3.销毁这个实例var temp = new String(&#x27;AtDawn&#x27;)const index = temp.indexOf(&#x27;w&#x27;)temp = nullconsole.log(index) // 4 拆箱：将引用数据类型转化为对应的基本数据类型的操作 123456789// 通过valueOf或者toString方法实现拆箱操作var objNum = new Number(123)var objStr = new String(&#x27;123&#x27;)console.log(typeof objNum) // objectconsole.log(typeof objStr) // objectconsole.log(typeof objNum.valueOf()) // numberconsole.log(typeof objStr.valueOf()) // stringconsole.log(typeof objNum.toString()) // stringconsole.log(typeof objStr.toString()) // string 12.null和undefined的异同点有哪些?相同点 都是空变量 都是假值，转布尔值都是false null == undefined 为 true 不同点 typeof判断null为object，判断undefined为undefined null转数字为0，undefined转数字为NaN null是一个对象未初始化，undefined是初始化了，但未定义赋值 null === undefined 为 false 13.如何判断数据类型? typeof xxx：能判断出number，string，undefined，boolean，object，function (null是object) Object.prototype.toString.call(xxx)：能判断出大部分类型 Array.isArray(xxx)：判断是否为数组 14.为什么typeof null是object?不同的数据类型在底层都是通过二进制表示的，二进制前三位为000则会被判断为object类型，而null底层的二进制全都是0，那前三位肯定也是000，所以被判断为object 15.==与===的区别? ==：在比较过程中会存在隐式转换 ===：需要类型相同，值相同，才能为true 16.JavaScript的隐式转换规则? 转成string类型：+ (字符串连接符) 转成number类型：++/– (自增自减运算符) + - */%(算术运算符) &gt; &lt; &gt;= &lt;= == != === !=== (关系运算符) 转成boolean类型：! (逻辑非运算符) 17.双等号左右两边的转换规则? null == undefined 为 true 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—false转换为0，而true转换为1 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值 如果一个操作数是对象，另一个操作数不是，则调用对象的toString()方法，用得到的基本类型值按照前面的规则进行比较 18.undefined &gt;= undefined 为什么是 false ?按照隐式转换规则，可转换成NaN &gt;= NaN，NaN不等于NaN，也不大于，所以是false 19.null &gt;= null 为什么是true?按照隐式转换规则,可转换成0&gt;=0，0等于0，所以是true 20.[ ] == ![ ] 为什么是true? !优先级高于==，[ ]不是假值，所以先转换成 ![ ] 等于 false 右边为布尔值,false再转成数字0 左边为对象，[ ]调用toString转为’ ‘，再转成数字0 最终就是0 == 0，所以为true 21. 0.1+0.2 === 0.3，对吗?不对，JavaScript的计算存在精度问题 1console.log(0.1+0.2 === 0.3) // false 原因：JavaScript中小数是浮点数，需转二进制进行运算，有些小数无法用二进制表示，所以只能取近似值，所以造成误差 解决方法： 先变成整数运算，然后再变回小数 toFixed() 性能不好，不推荐 22.什么是匿名函数?匿名函数：就是没有函数名的函数，如: 123(function(x,y)&#123; alert(x+y)&#125;)(2,3) 这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。 23.绑定点击事件有几种方式?三种 xxx.onclick = function (){} xxx.addEventListence(‘click’,function(){},false) 24.addEventListence的第三个参数是干嘛的?第三个变量传一个布尔值，需不需要阻止冒泡，默认是false，不阻止冒泡 25.函数声明和函数表达式的区别? 函数声明：享受函数提升 函数表达式：归类于变量声明，享受变量提升 函数提升优先级 &gt; 变量提升优先级 123456console.log(fun) // fun () &#123;&#125;// 函数表达式var fun = function(name) &#123;&#125;// 函数声明function fun () &#123;&#125;console.log(fun) // fun (name) &#123;&#125; 26.JavaScript的事件流模型有哪些? 事件冒泡：由最具体的元素接收，并往上传播 事件捕获：由最不具体的元素接收，并往下传播 DOM事件流：事件捕获 -&gt;目标阶段-&gt;事件冒泡 27.Ajax，Axios，Fetch有啥区别? Ajax：是对XMLHttpRequest对象(XHR)的封装 Axios：是基于Promise对XHR对象的封装 Fetch：是window的一个方法，也是基于Promise，但是与XHR无关，不支持IE 28.load，$(document).ready，DOMContentLoaded的区别?DOM文档加载的步骤为： 解析HTML结构 加载外部脚本和样式表文件 解析并执行脚本代码 DOM树构建完成 // DOMContentLoaded触发，$(document).ready触发 加载图片等外部文件 页面加载完毕 // load触发 29.如何阻止事件冒泡?1234567function stopBubble(e)&#123; if(e.stopPropagation)&#123; e.stopPropagation() &#125;else&#123; window.event.cancelBubble = true &#125;&#125; 30.如何阻止事件默认行为?1234567function stopDefault(e)&#123; if(e.preventDefault)&#123; e.preventDefault() &#125;else&#123; window.event.returnValue = false &#125;&#125; 31.什么是事件委托?当所有子元素需要绑定相同的事件的时候，可以把事件绑定在父元素上，这就是事件委托，优点有： 绑定在父元素上只需要绑定一次，节省性能 子元素不需要每个都去绑定同一事件 如果后续又有新的子元素添加，会由于事件委托的原因，自动接收到父元素的事件监听 32.如何实现数组去重?1234567891011121314151617// 使用 Map 去重function quchong1(arr) &#123; const newArr = [] arr.reduce((pre, next) =&gt; &#123; if(!pre.get(next))&#123; pre.set(next,1) newArr.push(next) &#125; return pre &#125;,new Map()) return newArr&#125;// 使用 Set 去重function quchong(arr)&#123; return [...new Set(arr)]&#125; 33.Set与Array的区别是什么?34.Map与Object的区别是什么?35.NaN是什么?有什么特点? NaN不等于自身，也就是NaN === NaN 为 false NaN为假值，转布尔值为false NaN本质是一个number，typeof NaN === number 36.处理异步的方法有哪些? 回调函数 promise 事件监听 发布订阅 async await 37.JavaScript继承方式有几种?前置工作 12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || &#x27;Animal&#x27; // 实例方法 this.sleep = function()&#123; console.log(this.name + &#x27;正在睡觉!&#x27;) &#125;&#125;// 原型方法Animal.prototype.eat = function(food)&#123; console.log(this.name + &#x27;正在吃：&#x27; + food)&#125; 1. 原型链继承 核心：将父类的实例作为子类的原型 1234567891011function Cat()&#123;&#125;Cat.prototype = new Animal()Cat.prototype.name = &#x27;cat&#x27;var cat = new Cat()console.log(cat.name) // catcat.eat(&#x27;fish&#x27;) // cat 正在吃：fishcat.sleep() // cat正在睡觉!console.log(cat instanceof Animal) // trueconsole.log(cat instanceof Cat) // true 优点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/属性，子类都能访问到 简单，易于实现 缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放构造器中 来自原型对象的所有属性被所有实例共享 创建子实例时，无法向父类构造函数传参 不支持多继承 2.构造继承 核心：使用父类的构造器来增强子类实例，等于是复制父类的实例属性给子类(没用到原型) 123456789function Cat(name)&#123; Animal.call(this) this.name = name || &#x27;Tom&#x27;&#125;var cat = new Cat()console.log(cat.name) // Tomcat.sleep() // Tom正在睡觉!console.log(cat instanceof Animal) // falseconsole.log(cat instanceof Cat) // true 优点： 解决了原型链继承中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承(call多个父类对象) 缺点： 实例并不是父类的实例，知识子类的实例 是能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3.实例继承 核心：为父类实例添加新特性，作为子类实例返回 1234567891011function Cat(name)&#123; var instance = new Animal(); instance.name = name || &#x27;Tom&#x27;; return instance;&#125;var cat = new Cat();console.log(cat.name) // Tomcat.sleep() // Tom正在睡觉！console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 优点： 不限制调用方式，不管是new子类()还是子类()，返回的对象具有相同效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 4.拷贝继承 核心：就一个一个拷贝 123456789101112function Cat(name)&#123; var animal = new Animal() for(var p in animal)&#123; Cat.prototype[p] = animal[p] &#125; this.name = name || &#x27;Tom&#x27;&#125;var cat = new Cat()console.log(cat.name) // Tomcat.sleep() // Tom正在睡觉!console.log(cat instanceof Animal) // falseconsole.log(cat instanceof Cat) // true 优点： 支持多继承 缺点： 效率低，内存占用高(因为要拷贝父类的属性) 无法获取父类不可枚举方法(不可枚举方法，不能使用for in访问到) 5.组合继承 核心：通过父类构造，继承父类的属性并保留传参的有点，然后通过将父类实例作为子类原型，实现函数复用 1234567891011function Cat(name)&#123; Animal.call(this) this.name = name || &#x27;Tom&#x27;&#125;Cat.prototype = new Animal()Cat.prototype.constructor = Catvar cat = new Cat()console.log(cat.name) // Tomcat.sleep() // Tom正在睡觉!console.log(cat instanceof Animal) // trueconsole.log(cat instanceof Cat) // true 优点： 弥补了构造继承的缺陷，可以继承实例属性/方法，也可继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例(子类实例将子类原型上的那份屏蔽了) 6.寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造时，就不会初始化两次实例方法/属性，避免继承组合的缺点 123456789101112131415function Cat(name)&#123; Animal.call(this) this.name = name || &#x27;Tom&#x27;&#125;// 创建一个没有实例方法的类var Super = function()&#123;&#125;Super.prototype = Animal.prototype// 将实例作为子类的原型Cat.prototype = new Super()// Test Codevar cat = new Cat()console.log(cat.name) // Tomcat.sleep() // Tom正在睡觉!console.log(cat instanceof Animal) // trueconsole.log(cat instanceof Cat) // true 优点： 堪称完美 缺点： 实现复杂 38.创建一个对象的方法有哪几种?new Object创建 12const obj = new Object()obj.name = &#x27;AtDawn&#x27; 字面量创建 1const obj = &#123;name:&#x27;AtDawn&#x27;&#125; 工厂模式创建 123456function createObj(name) &#123; const obj = new Object() obj.name = name return obj&#125;const obj = createObj(&#x27;AtDawn&#x27;) 构造函数创建 1234function Person(name) &#123; this.name = name&#125;const person = new Person(&#x27;AtDawn&#x27;) 39.this指向的四种情况? new操作符创建实例 123456function Person(name)&#123; this.name = name console.log(this)&#125;// this 指向当前person实例对象const person = new Person(&#x27;AtDawn&#x27;) 指向window 1234function fn()&#123; console.log(this)&#125;fn() // 浏览器里是window, node里是global 对象调用方法 12345678const target = &#123; fn: function()&#123;console.log(this)&#125;&#125;target.fn() // target// 这种就是改变了this了const fn = target.fnfn() // 浏览器里是window, node里是global call，apply，bind改变this 12345678910111213141516const obj1 = &#123; name：&#x27;AtDawn1&#x27;, sayName：function()&#123; console.log(this.name) &#125;&#125;const obj2 = &#123; name:&#x27;AtDawn2&#x27;&#125;// 改变sayName的this指向obj2obj1.sayName.call(obj2) // AtDawn2// 改变sayName的this指向obj2obj1.sayName.apply(obj2) // AtDawn2// 改变sayName的this指向obj2const fn = obj1.sayName.bind(obj2)fn() // AtDawn2 40.数组的常用方法有哪些? 方法 作用 是否影响原数组 push 在数组后添加元素，返回数组长度 √ pop 删除数组最后一项，返回被删除项 √ shift 删除数组第一项，并返回数组 √ unshift 数组开头添加元素，返回添加的元素 √ reserve 反转一个数组，返回修改后的数组 √ sort 排序一个数组，返回修改后的数组 √ splice 截取数组，返回被截取的区间 √ join arr.join(x)将arr数组元素连接成字符串并返回这个字符串 × concat arr1.concat(arr2,arr3)连接数组 × map 操作数组每一项并返回一个新数组 × forEach 遍历数组，没有返回值 × filter 对数组所有项进行判断，返回符合规则的新数组 × every 数组每一项都符合规则才返回true × some 数组有符合规则的一项就返回true × reduce 接收上一个return和数组的下一项 × flat 数组扁平化 × slice 截取数组，返回被截取的区间 × 41.Math的常用方法有哪些? 方法 作用 Math.max(arr) 取arr中的最大值 Math.min(arr) 取arr中的最小值 Math.ceil(小数) 小数向上取整 Math.floor(小数) 小数向下取整 Math.round(小数) 小数四舍五入 Math.sqrt(num) 对num进行开方 Math.pow(num,m) 对num取m次幂 Math.random()*num 取0-num的随机数 42.哪些因素导致内存泄露?如何解决?43.讲讲JavaScript的垃圾回收机制44.JS中有哪些不同类型的弹出框?在JS中有三种类型的弹出框可用，分别是： Alert Confirm Prompt 45.如何将JS日期转换为ISO标准toISOString()方法用于将js日期转换为ISO标准。它使用ISO标准将js Date对象转换为字符串 12345// 如var date = new Date()var n = date.toISOString()console.log(n)// YYYY-MM-DDTHH:mm:ss.sssZ 46.如何在JS中编码和解码URLencodeURL()函数用于解码js中的URL。它将url字符串作为参数并返回编码的字符串 注意：encodeURL()不会编码类似这样字符：/?:@&amp;=+$#，如果需要编码这些字符，请使用encodeURLComponent()。用法： 12var uri = &quot;my profile.php?name=sammer&amp;occupation=pāntiNG&quot;;var encoded_uri = encodeURI(uri); decodeURL()函数用于解码js中的URL。它将编码的url字符串作为参数并返回已解码的字符串，用法： 123var uri = &quot;my profile.php?name=sammer&amp;occupation=pāntiNG&quot;;var encoded_uri = encodeURI(uri);decodeURI(encoded_uri); 47.什么是BOM? 有哪些api?BOM就是browser object model，浏览器对象模型 api 作用 代表方法或属性 window.history 操纵浏览器的记录 history.back()history.go(-1) window.innerHeight 获取浏览器窗口的高度 window.innerWidth 获取浏览器窗口的宽度 window.location 操作刷新按钮和地址栏 location.host：获取域名和端口location.hostname：获取主机名location.port：获取端口号location.pathname：获取url的路径location.search：获取?开始的部分location.href：获取整个urllocation.hash：获取#开始的部分 location.origin：获取当前域名location.navigator：获取当前浏览器信息 48.BOM和DOM的关系BOM全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架 DOM全称Document Object Model，即文档对象模型，是HTML和XML的应用程序接口(API)，遵循W3C的标准，所有浏览器公共遵守的标准 JS是通过访问BOM(Browser Object Model)对象来访问，控制，修改客户端(浏览器),由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问，检索，修改XHTML文档内容与结构。因为document对象又是DOM的根节点 可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档 49.JS中的substr()和substring()函数有什么区别substr()函数的形式为substr(startIndex,length)。它从startIndex返回子字符串并返回’length’个字符数。 12var s = &#x27;hello&#x27;(s.substr(1,4) == &#x27;ello&#x27;) // true substring()函数的形式为substring(startIndex,endIndex)。它返回从startIndex到endIndex-1的子字符串。 12var s = &#x27;hello&#x27;(s.substring(1,4) == &#x27;ell&#x27;) // true 50.解释一下”use strict”?“use strict”是Es5中引入的js指令。使用”use strict”指令的目的是强制执行严格模式下的代码。在严格模式下，咱们不能在不声明变量的情况下使用变量。早期版本的js忽略了”use strict”。","categories":[{"name":"JS","slug":"JS","permalink":"https://lk-yu.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://lk-yu.github.io/tags/JS/"}]},{"title":"hexo搭建第一部分","slug":"hexo搭建第一部分","date":"2022-01-07T02:42:41.000Z","updated":"2022-01-07T08:43:50.278Z","comments":true,"path":"hexo搭建第一部分/","link":"","permalink":"https://lk-yu.github.io/hexo%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/","excerpt":"","text":"第一部分hexo的初级搭建还有部署到github page上，以及个人域名的绑定。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub或者Gitee 将Hexo部署到GitHub或者Gitee 设置个人域名 发布文章 1.安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 1sudo apt-get install git 安装好后，用git --version 来查看一下版本 2.安装nodejsHexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后,打开命令行 12node -vnpm -v 检查一下有没有安装成功 顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。 3.安装hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 1npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo 1hexo init myblog 这个myblog可以自己取什么名字都行，然后 12cd myblog //进入这个myblog文件夹npm install 新建完成后,指定文件夹目录下有: node_modules:依赖包 public:存放生成的页面 scaffolds:生成文章的一些模板 source:用来存放你的文章 themes:主题 _config.yml:博客的配置文件 12hexo ghexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。 使用ctrl+c可以把服务关掉。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://lk-yu.github.io/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lk-yu.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-01-07T02:20:35.328Z","updated":"2022-01-07T08:42:57.277Z","comments":true,"path":"hello-world/","link":"","permalink":"https://lk-yu.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"宣导","slug":"宣导","permalink":"https://lk-yu.github.io/categories/%E5%AE%A3%E5%AF%BC/"}],"tags":[]}],"categories":[{"name":"JS","slug":"JS","permalink":"https://lk-yu.github.io/categories/JS/"},{"name":"Blog","slug":"Blog","permalink":"https://lk-yu.github.io/categories/Blog/"},{"name":"宣导","slug":"宣导","permalink":"https://lk-yu.github.io/categories/%E5%AE%A3%E5%AF%BC/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://lk-yu.github.io/tags/JS/"},{"name":"xshell","slug":"xshell","permalink":"https://lk-yu.github.io/tags/xshell/"},{"name":"hexo","slug":"hexo","permalink":"https://lk-yu.github.io/tags/hexo/"}]}